from configs.STSSL_configs import STSSLConfig
from models.STSSL.aug import (
    aug_topology,
    aug_traffic,
)
from models.STSSL.layers import (
    STEncoder,
    SpatialHeteroModel,
    TemporalHeteroModel,
    MLP,
    FCLayer
)
from models.abstract_st_encoder import AbstractSTEncoder
from models.loss import masked_mae_loss


class STSSL(AbstractSTEncoder):
    def __init__(self, config: STSSLConfig, gp_supports):
        super(STSSL, self).__init__(config, gp_supports)
        self.aug_percent = config.aug_percent
        self.num_nodes = config.num_nodes
        self.c_in = config.c_in
        self.input_len = config.input_len
        self.output_len = config.output_len
        self.hidden_size = config.d_model
        self.temporal_part = config.temporal_percent

        # spatial temporal encoder
        self.encoder = STEncoder(Kt=3, Ks=3, blocks=[[self.config.c_in, int(self.hidden_size // 2), self.hidden_size],
                                                     [self.hidden_size, int(self.hidden_size // 2), self.hidden_size]],
                                 input_length=self.input_len, num_nodes=self.num_nodes, droprate=config.dropout)

        # traffic flow prediction branch
        self.mlp = MLP(self.hidden_size, config.c_out)
        self.mlp2 = FCLayer(self.output_len * self.hidden_size, config.input_len * config.c_in)
        # temporal heterogeneity modeling branch
        self.thm = TemporalHeteroModel(self.hidden_size, config.batch_size, self.num_nodes, self.device)
        # spatial heterogeneity modeling branch
        self.shm = SpatialHeteroModel(self.hidden_size, config.nmb_prototype, config.batch_size, config.shm_temp)
        self.mae = masked_mae_loss(mask_value=5.0)

    def forward(self, x, supports):
        view1 = x.permute(0, 3, 2, 1)
        graph = supports[0]  # view1: n,l,v,c; graph: v,v

        repr1 = self.encoder(view1, graph)  # N Lo V Dm

        s_sim_mx = self.fetch_spatial_sim()
        graph2 = aug_topology(s_sim_mx, graph, percent=self.aug_percent * 2)

        t_sim_mx = self.fetch_temporal_sim()
        view2 = aug_traffic(t_sim_mx, view1, percent=self.aug_percent)

        repr2 = self.encoder(view2, graph2)

        # calc forward loss
        self.forward_loss = self.temporal_loss(repr1, repr2) * self.temporal_part + \
                            self.spatial_loss(repr1, repr2) * (1 - self.temporal_part)

        pred = self.predict(repr1, repr2)
        residual = self.residual(repr1)

        return pred, residual

    def fetch_spatial_sim(self):
        """
        Fetch the region similarity matrix generated by region embedding.
        Note this can be called only when spatial_sim is True.
        :return sim_mx: tensor, similarity matrix, (v, v)
        """
        return self.encoder.s_sim_mx.cpu()

    def fetch_temporal_sim(self):
        return self.encoder.t_sim_mx.cpu()

    def predict(self, z1, z2):
        '''Predicting future traffic flow.
        :param z1, z2 (tensor): shape n1vc
        :return: ncvl, l=1, c=2
        '''
        z1 = z1.permute(0, 3, 2, 1)  # NLVC -> NCVL
        return self.mlp(z1)

    def residual(self, z):  # N Lo V Cm -> N Li V Ci
        # N Lo V Cm -> N V LoCm -> N LoCm V
        z = z.permute(0, 2, 1, 3).reshape(-1, self.num_nodes, self.output_len * self.hidden_size).permute(0, 2, 1)
        # N LoCm V 1
        z = z.unsqueeze(3)
        # N LiCi V 1
        z = self.mlp2(z)
        # N LiCi V 1 -> N V LiCi 1 -> N V Ci Li -> N Ci V Li
        z = z.permute(0, 2, 1, 3).reshape(-1, self.num_nodes, self.c_in, self.input_len).permute(0, 2, 1, 3)
        return z

    def temporal_loss(self, z1, z2):
        return self.thm(z1, z2)

    def spatial_loss(self, z1, z2):
        return self.shm(z1, z2)
